# ParallaxBA

## Paralaks Açısı Özellik Parametreliğini Kullanarak Paket Ayarı.

ParallaxBA, paralel açı özelliği parametreleştirmesine dayanan yeni bir paket ayarlama algoritmasıdır. Yeni parametrizasyonun, yakın ve uzaktaki özelliklerin farklı kamera hareketleri altında güvenilir şekilde temsil edilebileceği gösterilmiştir. Önerilen özellik parametrelerinin iyi bilgileri her zaman mevcuttur, çünkü sıfıra yakın paralaks nedeniyle bilgi matrisinin tekilliği önlenebilir. Dahası, yeni parametrelerin kullanılması, geleneksel Öklid XYZ'yi ve ters derinliği parametrizasyonu kullananlara kıyasla, objektif fonksiyonun daha iyi özelliklerine yol açar. Böylece ParallaxBA, mevcut BA algoritmalarıyla karşılaştırıldığında daha iyi yakınsama özelliklerine sahiptir.

Kurulum::

*cmake kurulumu.

image::https://github.com/umitkose1/ParallaxBA/blob/master/Screenshot_1.png?raw=true[]


libeigen3 kurulumu.

image::https://github.com/umitkose1/ParallaxBA/blob/master/Screenshot_2.png?raw=true[]

libsuitesparse kurulumu.

image::https://github.com/umitkose1/ParallaxBA/blob/master/Screenshot_3.png?raw=true[]

Calistirma::

* ParallaxBA -cam Cam90.txt -fea Feature90.txt -calib cal90.txt -solve GN -report report.txt.
 

* parallax veri setlerinin çalıştırılması ve çıkan sonuç.

image::https://github.com/umitkose1/ParallaxBA/blob/master/Screenshot_4.png?raw=true[]


Kod::

```java
static void pba_reprojectEachPts( double *KR, double* pa, double* pb, int nM, int nN, int nP, double n[2] )
{
	double *posei, *posek;
	double pti2k[3];
	double ptXUnit[3];
	double dDot, dDisi2k, dW2;
	double ptXk[3];
	double *posel;
	double pti2l[3];
	double ptXj[3];
	double *pKR;
	
	if ( nP == nM )	//Main archor
	{
		ptXj[0] = sin( pb[0] ) * cos( pb[1] );
		ptXj[1] = sin( pb[1] );
		ptXj[2] = cos( pb[0] ) * cos( pb[1] );

		pKR = KR + nP*9;
		n[0] = (pKR[0]*ptXj[0] + pKR[1]*ptXj[1] + pKR[2]*ptXj[2])/
			(pKR[6]*ptXj[0] + pKR[7]*ptXj[1] + pKR[8]*ptXj[2]);

		n[1] = (pKR[3]*ptXj[0] + pKR[4]*ptXj[1] + pKR[5]*ptXj[2])/
			(pKR[6]*ptXj[0] + pKR[7]*ptXj[1] + pKR[8]*ptXj[2]);
	}else 
		if ( nP == nN )	//Associate archor
		{
			posei = pa+6*nM+3;
			posek = pa+6*nN+3;

			pti2k[0] = posek[0]-posei[0];	pti2k[1] = posek[1]-posei[1];	pti2k[2] = posek[2]-posei[2];	

			ptXUnit[0] = sin( pb[0] ) * cos( pb[1] );
			ptXUnit[1] = sin( pb[1] );
			ptXUnit[2] = cos( pb[0] ) * cos( pb[1] );

			//compute angle w2
			dDot = ptXUnit[0]*pti2k[0] + ptXUnit[1]*pti2k[1] + ptXUnit[2]*pti2k[2];
			dDisi2k = sqrt( pti2k[0]*pti2k[0] + pti2k[1]*pti2k[1] + pti2k[2]*pti2k[2] );
			if (dDot/dDisi2k > 1)
				dW2 = 0;
			if ( dDot/dDisi2k < -1)
				dW2 = PI;
			else
				dW2  = acos( dDot/dDisi2k );

			//compute Xk vector according sin theory
			ptXk[0] = dDisi2k * sin( dW2+pb[2] ) * ptXUnit[0] - sin( pb[2] ) * pti2k[0];
			ptXk[1] = dDisi2k * sin( dW2+pb[2] ) * ptXUnit[1] - sin( pb[2] ) * pti2k[1];
			ptXk[2] = dDisi2k * sin( dW2+pb[2] ) * ptXUnit[2] - sin( pb[2] ) * pti2k[2];

			pKR = KR + nN*9;		
			n[0] = ( pKR[0]*ptXk[0]	+ pKR[1]*ptXk[1] + pKR[2]*ptXk[2])/
				( pKR[6]*ptXk[0] + pKR[7]*ptXk[1] + pKR[8]*ptXk[2]);

			n[1] = ( pKR[3]*ptXk[0]	+ pKR[4]*ptXk[1] + pKR[5]*ptXk[2])/
				(pKR[6]*ptXk[0]	+ pKR[7]*ptXk[1] + pKR[8]*ptXk[2]);
		}
		else
		{
			posel = pa + nP*6 + 3;
			posek = pa + nN *6 + 3;
			posei = pa + nM *6 + 3;

			pti2k[0] = posek[0] - posei[0];		pti2k[1] = posek[1] - posei[1];		pti2k[2] = posek[2] - posei[2];
			pti2l[0] = posel[0] - posei[0];		pti2l[1] = posel[1] - posei[1];		pti2l[2] = posel[2] - posei[2];
			
			//XUnit
			ptXUnit[0] = sin( pb[0] ) * cos( pb[1] );
			ptXUnit[1] = sin( pb[1] );
			ptXUnit[2] = cos( pb[0] ) * cos( pb[1] );

			//compute angle w2
			dDot = ptXUnit[0]*pti2k[0] + ptXUnit[1]*pti2k[1]+ ptXUnit[2]*pti2k[2];
			dDisi2k = sqrt( pti2k[0]*pti2k[0] + pti2k[1]*pti2k[1] + pti2k[2]*pti2k[2] );
			//dW2  = acos( dDot/dDisi2k );
			if (dDot/dDisi2k > 1)
				dW2 = 0;
			if ( dDot/dDisi2k < -1)
				dW2 = PI;
			else
				dW2  = acos( dDot/dDisi2k );

			//compute Xl vector according sin theory
			ptXk[0] = dDisi2k * sin( dW2+pb[2] ) * ptXUnit[0] - sin( pb[2] ) * pti2l[0];
			ptXk[1] = dDisi2k * sin( dW2+pb[2] ) * ptXUnit[1] - sin( pb[2] ) * pti2l[1];
			ptXk[2] = dDisi2k * sin( dW2+pb[2] ) * ptXUnit[2] - sin( pb[2] ) * pti2l[2];

			pKR = KR + nP*9;			
			n[0] = (pKR[0]*ptXk[0] + pKR[1]*ptXk[1] + pKR[2]*ptXk[2])/
				( pKR[6]*ptXk[0] + pKR[7]*ptXk[1] + pKR[8]*ptXk[2]);

			n[1] = (pKR[3]*ptXk[0] + pKR[4]*ptXk[1] + pKR[5]*ptXk[2])/
				( pKR[6]*ptXk[0] + pKR[7]*ptXk[1] + pKR[8]*ptXk[2]);
		}
}
```

Bu kod ile her görüntü noktasının görüntü koordinatları hesaplanmaktadır.


```java
double
SlamGMapping::computePoseEntropy()
{
  double weight_total=0.0;
  for(std::vector<GMapping::GridSlamProcessor::Particle>::const_iterator it = gsp_->getParticles().begin();
      it != gsp_->getParticles().end();
      ++it)
  {
    weight_total += it->weight;
  }
  double entropy = 0.0;
  for(std::vector<GMapping::GridSlamProcessor::Particle>::const_iterator it = gsp_->getParticles().begin();
      it != gsp_->getParticles().end();
      ++it)
  {
    if(it->weight/weight_total > 0.0)
      entropy += it->weight/weight_total * log(it->weight/weight_total);
  }
  return -entropy;
}
```

buradaki kod ile agirlik hesaplamasi yapiliyor.

```java
void
SlamGMapping::updateMap(const sensor_msgs::LaserScan& scan)
{
  ROS_DEBUG("Update map");
  boost::mutex::scoped_lock map_lock (map_mutex_);
  GMapping::ScanMatcher matcher;

  matcher.setLaserParameters(scan.ranges.size(), &(laser_angles_[0]),
                             gsp_laser_->getPose());

  matcher.setlaserMaxRange(maxRange_);
  matcher.setusableRange(maxUrange_);
  matcher.setgenerateMap(true);

  GMapping::GridSlamProcessor::Particle best =
          gsp_->getParticles()[gsp_->getBestParticleIndex()];
  std_msgs::Float64 entropy;
  entropy.data = computePoseEntropy();
  if(entropy.data > 0.0)
    entropy_publisher_.publish(entropy);

  if(!got_map_) {
    map_.map.info.resolution = delta_;
    map_.map.info.origin.position.x = 0.0;
    map_.map.info.origin.position.y = 0.0;
    map_.map.info.origin.position.z = 0.0;
    map_.map.info.origin.orientation.x = 0.0;
    map_.map.info.origin.orientation.y = 0.0;
    map_.map.info.origin.orientation.z = 0.0;
    map_.map.info.origin.orientation.w = 1.0;
  } 

  GMapping::Point center;
  center.x=(xmin_ + xmax_) / 2.0;
  center.y=(ymin_ + ymax_) / 2.0;

  GMapping::ScanMatcherMap smap(center, xmin_, ymin_, xmax_, ymax_, 
                                delta_);

  ROS_DEBUG("Trajectory tree:");
  for(GMapping::GridSlamProcessor::TNode* n = best.node;
      n;
      n = n->parent)
  {
    ROS_DEBUG("  %.3f %.3f %.3f",
              n->pose.x,
              n->pose.y,
              n->pose.theta);
    if(!n->reading)
    {
      ROS_DEBUG("Reading is NULL");
      continue;
    }
    matcher.invalidateActiveArea();
    matcher.computeActiveArea(smap, n->pose, &((*n->reading)[0]));
    matcher.registerScan(smap, n->pose, &((*n->reading)[0]));
  }

  // the map may have expanded, so resize ros message as well
  if(map_.map.info.width != (unsigned int) smap.getMapSizeX() || map_.map.info.height != (unsigned int) smap.getMapSizeY()) {

    // NOTE: The results of ScanMatcherMap::getSize() are different from the parameters given to the constructor
    //       so we must obtain the bounding box in a different way
    GMapping::Point wmin = smap.map2world(GMapping::IntPoint(0, 0));
    GMapping::Point wmax = smap.map2world(GMapping::IntPoint(smap.getMapSizeX(), smap.getMapSizeY()));
    xmin_ = wmin.x; ymin_ = wmin.y;
    xmax_ = wmax.x; ymax_ = wmax.y;
    
    ROS_DEBUG("map size is now %dx%d pixels (%f,%f)-(%f, %f)", smap.getMapSizeX(), smap.getMapSizeY(),
              xmin_, ymin_, xmax_, ymax_);

    map_.map.info.width = smap.getMapSizeX();
    map_.map.info.height = smap.getMapSizeY();
    map_.map.info.origin.position.x = xmin_;
    map_.map.info.origin.position.y = ymin_;
    map_.map.data.resize(map_.map.info.width * map_.map.info.height);

    ROS_DEBUG("map origin: (%f, %f)", map_.map.info.origin.position.x, map_.map.info.origin.position.y);
  }

  for(int x=0; x < smap.getMapSizeX(); x++)
  {
    for(int y=0; y < smap.getMapSizeY(); y++)
    {
      /// @todo Sort out the unknown vs. free vs. obstacle thresholding
      GMapping::IntPoint p(x, y);
      double occ=smap.cell(p);
      assert(occ <= 1.0);
      if(occ < 0)
        map_.map.data[MAP_IDX(map_.map.info.width, x, y)] = -1;
      else if(occ > occ_thresh_)
      {
        //map_.map.data[MAP_IDX(map_.map.info.width, x, y)] = (int)round(occ*100.0);
        map_.map.data[MAP_IDX(map_.map.info.width, x, y)] = 100;
      }
      else
        map_.map.data[MAP_IDX(map_.map.info.width, x, y)] = 0;
    }
  }
  got_map_ = true;

  //make sure to set the header information on the map
  map_.map.header.stamp = ros::Time::now();
  map_.map.header.frame_id = tf_.resolve( map_frame_ );

  sst_.publish(map_.map);
  sstm_.publish(map_.map.info);
}
```

kodun bu parcasinda ise harita guncelleme adimi islemi yapiliyor.


